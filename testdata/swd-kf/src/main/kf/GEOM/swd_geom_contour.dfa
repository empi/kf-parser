#! NX/KF 4.0

DefClass: swd_geom_contour (ug_base_part);


(Boolean Modifiable Parameter Canonical) 	use_contour:			true;
(Boolean Modifiable Parameter Canonical)	revolve_contour?:	false;
(Boolean Modifiable Parameter Canonical)	bottom_half?:			false;
(String Modifiable Parameter Canonical) 	cdf_file_name: 			"";

(Number Modifiable Parameter)   DS1_value:			0;
(Number Modifiable Parameter)   DS2_value:			0;

(Number Modifiable)							hidden_layer: 240;



(Child) Contour: {
  Class, com_geom_linked_contour;
  cdf_file_name, if !use_contour: then "" else	cdf_file_name:;
  file_rev, 	"";
  hidden_layer, hidden_layer:;
  Feature_Set_Name, "Contour";
  included_contours, if !use_contour: then {} else  {1, 4, 5 };
};

(Any) ContourSpline: @{
	 $res << if use_contour: then 	
	   Contour:JoinedContour:Output_Curve_0:
	 else 0;
	 ug_printValues({$res});
	 $res;
};

(Child) DS1Expression: {
  Class, ug_expression_number;
  Units, "";
  value, ds1_switched_Value:;
	name, "DS1",
	demandOrder, { Contour:, DummyPoint: };
};

(Child) DS2Expression: {
  Class, ug_expression_number;
  Units, "";
  value, ds2_switched_Value:;
	name, "DS2",
	demandOrder, { Contour:, DummyPoint: };
};

(Child) SideWallSize: {
  Class, ug_expression_number;
  Units, "";
  value, ds2_switched_Value: - ds1_switched_Value:;
	name, "SW_Height",
	demandOrder, { DummyPoint: };
};

(Child) DS1Arc: {
	Class, ug_arc;
  Radius, DS1Expression:Value:;
  start_angle, 0;
  end_angle, 360;
  center, Point(0,0,0);
  x_axis, Vector(0,1,0);
  y_axis, Vector(0,0,1);
  demandOrder, { Contour:, DS1Expression:  };
};

(Child) DS2Arc: {
	Class, ug_arc;
  Radius, DS2Expression:Value:;
  start_angle, 0;
  end_angle, 360;
  center, Point(0,0,0);
  x_axis, Vector(0,1,0);
  y_axis, Vector(0,0,1);
  demandOrder, { Contour:, DS2Expression: };
};

# revolve tire body
(Child) ContourRevolve: {
  Class, if use_contour: then swd_geom_contour_revolve else nulldesign;
  section_curves, {Contour:JoinedContour: };
	hidden_layer,	hidden_layer:;
	demandOrder, {Contour:},
};

(Method Any) store_ds1_ds2:()
@{
	if( use_contour:) then 
	@{
	  $radii << ds1_ds2_radii:;
		StoreValue( first($radii),self(), DS1_Value );
		StoreValue( second($radii),self(), DS2_Value );
		ug_setExpressionValue_( "" , DS1Expression: , format("%f", DS1_value: ) );
		ug_setExpressionValue_( "" , DS2Expression: , format("%f", DS2_value: ) );
	}
	else
 	@{
		0;# gets set per parameter passing, no need to do anything here			
	};
};


(List) ds1_ds2_radii:
@{
	if use_contour: then
	@{
		$ds1_ds2_curves << ug_container_askFeatureCurves( {Contour:Cont5:} );
		$possible_ds_points << if( bottom_half?: ) then loop
		{
			for $curve in $ds1_ds2_curves;
			for $start is ug_curve_askStartPoint( $curve);
			for $end 	 is ug_curve_askEndPoint($curve);
			if (localx($start) < 0 && localx($end) < 0) collect {$start, $end};
		} else loop
		{
			for $curve in $ds1_ds2_curves;
			for $start is ug_curve_askStartPoint( $curve);
			for $end 	 is ug_curve_askEndPoint($curve);
			if (localx($start) > 0 && localx($end) > 0) collect {$start, $end};
		};
	
	  $radii << identify_ds1_ds2:($possible_ds_points);
	} else 
	{Point(0,0,0), Point(100,10,0)}; # arbitrary default values
};

# switches between UI entered values and 
# contour specified ones
# and forces dependencies/ updates
# on Contour swapping
(Number) ds1_switched_Value:
@{
	if( use_contour:) then 
	@{
		first(ds1_ds2_radii: );
	}
	else
 	@{
		DS1_value:;			
	};
};

# switches between UI entered values and 
# contour specified ones
# and forces dependencies/ updates
# on Contour swapping
(Number) ds2_switched_Value:
@{
	if( use_contour:) then 
	@{
		Second(ds1_ds2_radii:);
	}
	else
 	@{
		DS2_value:;			
	};
};


# expects a list of point pairs;
# returns two radii as List of Numbers

(Method List) identify_ds1_ds2:(
 List $possible_point_pairs
 )
@{
	# figure out if we need to switch the pairs
	$ll << loop {
		for $point_pair in $possible_point_pairs;
		collect minlist( loop {
			for $p in $point_pair;
			collect localy($p);
		});
	};
  $sorted_pairs << if first($ll) > second($ll) then {second($possible_point_pairs), first($possible_point_pairs)} else $possible_point_pairs;
	# now the first point pair relates to DS1, second to DS2
	# now figure out, which one of those two points is the left-most
	# and we have our radii
	$ds1_radius << @{
		$point_pair << first($sorted_pairs);
		if(localx(first($point_pair))>  localx(second($point_pair))) then localy(second($point_pair)) else localy(first($point_pair));
	};
	$ds2_radius << @{
		$point_pair << second($sorted_pairs);
		if(localx(first($point_pair))>  localx(second($point_pair))) then localy(second($point_pair)) else localy(first($point_pair));
	};
	{$ds1_radius, $ds2_radius };
};

