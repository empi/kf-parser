#! NX/KF 4.0

DefClass: swd_geom_font (ug_base_part swd_constants);


(Point Parameter Modifiable) root_origin: Point(0,0,0);


# 95 regular ASCII characters, 10 extra symbols, minus one 'space'/blank -> 103
(Integer Parameter Modifiable) number_of_childs: 104;  

# set this to false if you want to delete some geometry
# but KF won't let you because it is part of
# adopted_curves:
(Boolean Parameter Modifiable) do_adopt_curves?: false;

(Number) default_line_spacing: 4;
#+
graphical explanation of variables:

-------------- <-dist-> -------
|  |      |  |          |
|------------           -------
|	 |<size>|  |          |
|	 |      |  |          |
|------------
|	 |      |  |
-------------
<  >      <  >
 |         |
   overhang
#-


# distance between glyph cages
(Number Parameter) dist: 20;

# outer border area edge length
(Number Parameter) overhang: size: / 2;

# inner area edge length
(Number Parameter) size: swd_defaultFontHeight(); #defined in swd_constants



#(Integer Parameter Modifiable) number_of_childs: 10;  
#  maximum of 4 lines (3 'full' lines and the remainding glyphs on an extra line)
(Integer) glyphs_per_line: floor(number_of_childs: / 3);



# auto compute following attributes even if noone asked for them
(List) demandValue: {adopted_curves, curve_types, spline_knots, localised_curves, anchor_points};

# saving this class inside the appropriate part files
(Boolean) saveClass?: false;
# which values should be saved?
(List) saveValue: {localised_curves, spline_knots, curve_types, glyphcage_center_vectors, bounding_boxes, spline_degrees,spacing_tables, spacing_table_descriptions, width_table };


# list of spacing tables, where one 
# spacing table is {character_spacings, line_spacing}
# where character_spacings is a list of lists of numbers
# and line_sapcing a single number
(List Modifiable cached) spacing_tables: {};


# list of {spacing table name, index} tuples
(List modifiable cached) spacing_table_descriptions:
{
};

# list of numbers, 
(List modifiable cached) width_table:
{
};



#+ list of a 'hash' containing the 9 anchor points, all combinations of
(vertical)	X		(horizontal) 
top							left
middle					center
bottom 					right

where top always is 100
and bottom always is 0
due to the way the characters are drawn into their glyph cages
think of glyph " (quote) -- the bounding box is considerably ABOVE bottom line (which has Y = 0 = const),
nevertheless the lower anchor points are always exactly on bottom line
#-

(List) anchor_points:
loop{
	# init
	for $bounds in bounding_boxes:;
	for $minPoint is first($bounds);
	for $maxPoint is second($bounds);
	for $minX 		is localx($minPoint);
	for $minY 		is 0;
	for $maxX 		is localx($maxPoint);
	for $maxY 		is size:;
	for $midX			is $minX + ($maxX - $minX) /2;
	for $midY			is $minY + ($maxY - $minY) /2;
	# compute 
	for	$bottom_left 		is	Point($minX,								$minY,					 		0);
	for $bottom_center 	is	Point($midX,								$minY,					 		0);
	for $bottom_right		is  Point($maxX,								$minY,					 		0);
	#
	for $middle_left		is	Point($minX ,								$midY, 							0);
	for $middle_center	is	Point($midX,								$midY, 							0);
	for $middle_right		is	Point($maxX,								$midY, 							0);
	#
	for $top_left				is	Point($minX,								$maxY,	 						0);
	for $top_center			is	Point($midX,								$maxY,							0);
	for $top_right			is	Point($maxX,								$maxY,							0);

	collect {{"bottom_left", $bottom_left}, {"bottom_center", $bottom_center}, 	{"bottom_right", $bottom_right},
					 {"middle_left", $middle_left}, {"middle_center", $middle_center}, 	{"middle_right", $middle_right},
					 {"top_left", $top_left}, 			{"top_center", $top_center}, 				{"top_right", $top_right}};
};

(List cached) spline_degrees:
loop{
		for $curves_list in adopted_curves:;
		append{
			loop{
				for $curve in $curves_list;
				for $curve_type is ug_object_askType( $curve );
				append{
					if($curve_type  = "ug_spline_cntl" | $curve_type = "ug_spline_thru" )then
						com_getSplineDegree($curve)
          else -1  # if it's not a spline, use a non-sensical value instead.
				};
			};
		};
};


(List) bounding_boxes:
loop{
	for $curves in localised_curves:;
	for $xyBoundingBox is swd_askXYBoundingBoxList( $curves );
	collect $xyBoundingBox;
};


(List) adopted_curves: 
if do_adopt_curves?: then
	{{}} + # collect an empty list for space, ' ', the 0 of characters
	loop{
    for $cage_counter from 1 to number_of_childs:;
    append {askEnclosedCurves:($cage_counter)};
  } 
else {{}} + loop{
	for $cage_counter from 1 to number_of_childs:;
	collect {};
}; 

(List cached) curve_types:
loop{
	for $curves in adopted_curves:;
	for $types is loop{
		for $curve in $curves;
		collect ug_object_askType( $curve );
	};
	collect $types;
};

(List cached) spline_knots: loop{
	for $list_of_curves in adopted_curves:;
  for $knots is loop{ 
		for $curve in $list_of_curves;
  	append { 
	   if(ug_object_askType( $curve ) = "ug_spline_cntl") 
		 then com_getSplineKnotsList ($curve)
		 else {} # append an empty list if it's not a spline, so indexing doesn't get confused
    };
  };
	collect $knots;		
};


(Number Modifiable) sample_width: 1.0;


(List cached) sampled_curves:
Loop {
	# iterate over all glyphs
	# iterate over each curve per glyph
	# then sample the curve depending on its type
 For $list_of_curves In adopted_curves:;
 collect  loop{ 
	for $curve in $list_of_curves;
	for $curve_type is ug_object_askType( $curve );
	# remove me
	do if $curve_type =  "nx_studio_spline" then debug_printValues({"*****nx_studio_spline****"}) else 0;
	 append {
	 if($curve_type  = "ug_spline_cntl" | $curve_type = "ug_spline_thru" )
		then flatten( getSplineControlPoints:( $curve)) 
		else if($curve_type = "nx_line" ) 
		then flatten( sampleLine:($curve))
		else flatten(
		  {ug_curve_askStartPoint( $curve ), 
      Loop {
       For $sampling_point_index From 1 To ceil(nx_askArcLength( $curve )/sample_width:)-1 By 1;
       append{ ug_curve_askPointOnCurve( $curve, ug_curve_askStartParameter( $curve ) + (ug_curve_askEndParameter( $curve )
			          - ug_curve_askStartParameter( $curve ) )*$sampling_point_index/(ceil(nx_askArcLength( $curve )/sample_width:)) )};
	    },
		  ug_curve_askEndPoint( $curve )}
			);
		};
	};

};

#  vectors pointing to the center of each glyph cage
(List) glyphcage_center_vectors:
{Vector(0,0,0)} + # for space character
loop{
	for $cage_counter from 1 to number_of_childs:;
	for $footPoint is askGlyphFootPoint:($cage_counter);
	append{ com_Point2Vector($footPoint) };
};


# list of glyph curves normalised around the origin
# that is, in OpenGL speak, Model Space, not Camera/World Space
(List) localised_curves:
  if(do_adopt_curves?:) then
  @{
    writeStatus("Collecting localised curves. Please wait.");
    $curves << loop{
      for $curve_counter from 1 to number_of_childs:;
      for $localised_glyph is loop{
        for $curve in nth($curve_counter, sampled_curves:);
        for $localised_points is loop {
          for $the_point in $curve;
          collect $the_point - nth($curve_counter, glyphcage_center_vectors:);
          }; 
        collect $localised_points;
      };
      collect $localised_glyph;
    };
    writeStatus("Finished collecting localised curves.");
    $curves;
  }
  else
  adopted_curves:; # re-use the empty list of lists

#+
###### Methods 
#-	

#+
Computes the left_bottom corner of glyph_cage indexed by $glyph (starting from 1) 
#-
(Point Method) askCageStartingPoint:(Number $glyph_index)
@{
						
	$cage_index << $glyph_index - 1;		
	Point(LocalX(root_origin:) + (mod(($cage_index ), glyphs_per_line:)) * # break up in row/column 
				     (size: + dist: + 2* overhang:) - (size:/2)  - overhang:, # column   
								LocalY(root_origin:) + floor(($cage_index) / glyphs_per_line:) *(size:  + dist: + 2* overhang:) - overhang:, # row 
								LocalZ(root_origin:)); # const
							
};


(Point Method) askGlyphFootPoint:(Number $glyph_index)
@{
							$cage_start << askCageStartingPoint:($glyph_index);
							$x_coord << LocalX($cage_start) + (size:/2) + overhang:;
              $y_coord << LocalY($cage_start) + overhang:;
							$z_coord << LocalZ($cage_start);
							Point($x_coord, $y_coord, $z_coord);
};



(List Method) askCageBoundingPoints:(Number $cage_index)
@{
	$starting_point << askCageStartingPoint:($cage_index);  
	$end_point << Point( LocalX($starting_point) + size: + 2 * overhang:, LocalY($starting_point) + size: + 2 * overhang:  , LocalZ(  $starting_point ));
	{$starting_point, $end_point };	
};


(List Method) highlightEnclosedCurves:(Number $cage_index)
@{
	$curves << askEnclosedCurves:($cage_index);
	$highlight_ok << Loop {
		For $obj In $curves;
		append {highlight({$obj})};
	};
	$highlight_ok;
};

(List Method) getSplineControlPoints:(Any $curve)
@{
	$list_of_coord_lists << com_getSplineControlPointList($curve);
	loop{
		for $i from 1 to length($list_of_coord_lists);
		collect{ nth($i,$list_of_coord_lists)};
	};
};

(List Method) getSplineKnots:(Any $list_of_curves)
@{
 loop{
		for $curve in $list_of_curves;
  	append { 
	   if(ug_object_askType( $curve ) = "ug_spline_cntl") 
		 then com_getSplineKnotsList ($curve)
	   else {} # append an empty list if it's not a spline, so indexing doesn't get confused
    };
  };
};

(List Method) askEnclosedCurves:(Number $cage_index)
@{

	# get bounding box corner points
	$cage_bounding_box <<  askCageBoundingPoints:( $cage_index);
	# split them
	$low_border << first(	$cage_bounding_box );
	$high_border << second(	$cage_bounding_box );
	# collect all curves we might be interested in
	$all_potential_curves << ug_cycleObjectsByType( {nx_studio_spline, ug_spline, nx_spline, ug_line, nx_line, ug_arc, nx_arc,  ug_spline_thru, ug_ellipse, nx_ellipse, your_ad_here }, "", "cycle", Identity, "args", 0 );
	# now sort out all wrong ones
	$enclosed_curves << Loop {
		For $obj In $all_potential_curves ;
		for $closest_lower 	is com_askClosestPointOnCurve($obj, $low_border);
		for $closest_high 	is com_askClosestPointOnCurve($obj, $high_border);	
    for $x_is_in? is ( LocalX($low_border) < LocalX($closest_lower )) & LocalX($high_border) >  LocalX($closest_high);
		for $y_is_in? is ( LocalY($low_border) < LocalY($closest_lower ) & LocalY($high_border) >  LocalY($closest_high ));
		if ( $x_is_in? & $y_is_in?  )	Append  {$obj}; 
	};
	$enclosed_curves; 
};


(List Method ) sampleLine:(Any $curve)
@{
	# ug_spline_thru expects a t least 4 points
	# so we're gonna use the start, end
	# and two points in between
	$start << ug_curve_askStartPoint($curve);
	$end << 	ug_curve_askEndPoint($curve);
	$delta_vec << $end - $start;

	{$start, $start + 0.3 * $delta_vec, $start + 0.6 * $delta_vec, $end};
};

(List Method) availableSpacingTablesNames:()
@{
	debug_printValues({"enter availableSpacingTablesNames:()"});
  $data <<	loop{
    for $table_description in spacing_table_descriptions:;
    collect first($table_description);
	};

	debug_printValues({"exit  availableSpacingTablesNames:()"});
	$data;
};



(List) character_map:
swd_displayCharacterMap();

(List Method) importSpacingFromExcelSheet:(String $excelfile, Integer $sheetindex, String $table_name)
@{
	debug_printValues({"in importSpacingFromExcelSheet, using values", $excelfile, " ", $sheetindex, " ", $table_name});
	$added_spacings << readSpacingFromExcelSheet:($excelfile,  $sheetindex);
	if(! Empty?($added_spacings)) then @{
    $complete_Spacings << {$added_Spacings, default_line_spacing:};
    $old_spacings << spacing_tables:;
    $new_spacings << $old_spacings + {$complete_spacings};
    $next_index << length($old_spacings) +1;
    $old_descr << spacing_table_descriptions:;
    $new_descr << $old_descr + {{$table_name, $next_index}};
    StoreValue($new_spacings, self:, spacing_tables);
    StoreValue($new_descr, self:, spacing_table_descriptions);
		debug_printValues({"finishing importSpacingFromExcelSheet, storage says: ", spacing_table_descriptions:, " ", spacing_tables: });
    {$new_descr, $new_Spacings};
	} else @{
		debug_printValues({"added spacing is empty."});
		{};
  };
};

(List Method) readSpacingFromExcelSheet:(String $excelfile, Integer $sheetindex)
@{
 $port <<	ug_excel_open_file($excelfile, READ);
 if($port != 0) then @{
	 $row_start << 2; # skip row/column 'label'
	 $col_start << 2; # skip row/column 'label'
	 $row_end << $row_start + length(swd_characterMap());
 	 $col_end << $col_start + length(swd_characterMap());
   $raw_data << ug_excel_read_range($port, $sheetindex, $row_start,$col_start, $row_end, $col_end); #read first 105x105 cells
   $closing_ok << ug_excel_close_file($port, FALSE); # save = false
   # TODO handle closing not ok
		$listlist_of_Values << com_excel_ask_values_2d($raw_data);	
		$values << loop {
			for $row in $listlist_of_values;
			collect loop {
				for $cell in $row;
				collect if($cell != "NoValue") then com_excel_make_number($cell) else 0;
			};
		};
		$values;
 } else @{
   debug_printValues({"Could not open file ", $excelfile});
	 {};
  };
};


(List Method) importWidthFromExcelSheet:(String $excelfile, Integer $sheetindex)
@{
	debug_printValues({"in importWidthFromExcelSheet, using values", $excelfile, " ", $sheetindex});
	$new_widths << readWidthFromExcelSheet:($excelfile,  $sheetindex);
	if(! Empty?($new_widths)) then @{
    StoreValue($new_widths, self:, width_table);
		debug_printValues({"finishing importWidthFromExcelSheet, storage says: ", width_table: });
		$new_widths;
	} else @{
		debug_printValues({"added wth table is empty."});
		{};
  };
};


(List Method) readWidthFromExcelSheet:(String $excelfile, Integer $sheetindex)
@{
 $port <<	ug_excel_open_file($excelfile, READ);
 if($port != 0) then @{
   $raw_data << ug_excel_read_range($port, $sheetindex, 1, 1, 1,105); #read first 105x105 cells
   $closing_ok << ug_excel_close_file($port, FALSE); # save = false
   # TODO handle closing not ok
	 # get rid of excel header data that automagically gets inserted
  	$real_data << if(length($raw_data )> 5)	then 	 sublist($raw_data, 6, length($raw_data)) else {};
		loop {
			for $item in $real_data;
			collect com_excel_make_number($item);
		};
 } else @{
   debug_printValues({"Could not open file ", $excelfile});
	 {};
  };
};

#+
Writes a spacing table to an excel 97 file.
String $excelfile: fully qualified path to excel file.
If the file already exist, the data will be overwritten without warning!
If the file doesn't exist, a new one will be created.
Integer $table_index: index (startng from 1) of the spacing table to be written out.
#-
(Boolean Method) writeSpacingTableToExcel:(String $excelfile, Integer $table_index)
@{
	debug_printValues({"begin writeSpacingTableToExcel"});
	$port << ug_excel_open_file($excelfile, Write);
	if($port != 0) then @{
		$sheet_id << 1;
		$row_start << 1;
		$row_end << $row_Start + length(swd_characterMap()); 
		$col_start << 1;		
		$col_end << $col_start + length(swd_characterMap());
		$header << {$sheet_id, $row_start, $col_start, $row_end, $col_end};
		$col_headlines <<  swd_displayCharacterMap(); 
		
		$selected_table << first(nth($table_index, spacing_tables: ));
		$cell_data << flatten( loop { # zip the col headlines into the raw data
			for $row_index from 1 to length($col_headlines); 
			for $col_headline is nth($row_index, $col_headlines);# start each row with the headline of the corresponding column to make the grid
			for $row is nth($row_index, $selected_table); 
			collect {$col_headline} + loop {
				for $val in $row;
				collect com_excel_make_String($val);
			};
		});  	
		$data << $header +{""}+ $col_headlines + $cell_data;		
		ug_excel_write_range($port, $data);
		$do_save << true;
		$close_successful << ug_excel_close_file($port, $do_save);		
		# TODO handle $close_successful = false;
	} else @{
		ug_printValues({"writeSpacingTableToExcel: couldn't open file ", $excelfile });
		false;
	};
};

#+
 Writes the width table to an excel 97 file.
 String $excelfile: fully qualified path to excel file.
 If the file already exist, the data will be overwritten without warning!
 If the file doesn't exist, a new one will be created.
#-
(Boolean Method) writeWidthTableToExcel:(String $excelfile)
@{
	debug_printValues("enter writeWidthTableToExcel");
	$port << ug_excel_open_file($excelfile, Write);
	if($port != 0) then @{
		$sheet_id << 1; # which spread sheet
		$row_start << 2;
		$row_end << $row_start;
		$col_start << 1;		
		$col_end << $col_start + length(width_table:)-1;
		$header << {$sheet_id, $row_start, $col_start, $row_end, $col_end};
		$cell_data << loop {
			for $cel_val in width_table:;
			collect com_excel_make_String($cel_Val);
		};
		$data << $header + $cell_data;
		ug_excel_write_range($port, $data);
		$do_save << true;
		$close_successful << ug_excel_close_file($port, $do_save);
		debug_printValues("exit writeWidthTableToExcel");
		$close_successful;
		# TODO handle $close_successful = false;
	} else @{
		debug_printValues({"writeWidthTableToExcel: couldn't open file ", $excelfile });
		false;
	};
};

(Any Method) storeSpacingValue:(Integer $spacing_table_index, Integer $left_hand_char, Integer $right_hand_char, Number $spacing_value)
@{
	$char_spacing_table << first(nth($spacing_table_index, spacing_tables:)); # spacing_tables_entry := {{spacings},line_spacing_Value}
	$spacing_row_for_character << nth($left_hand_char, $char_spacing_table);
	$new_spacing_row << com_list_replaceNthItem($spacing_row_for_character, $right_hand_char, $spacing_Value);
	$new_char_spacing_table << com_list_replaceNthItem($char_spacing_table, $left_hand_char, $new_spacing_row);
	$new_spacing_table << com_list_replaceNthItem(nth($spacing_table_index, spacing_tables:), 1, $new_char_spacing_table);	
	$updated_spacing_tables << com_list_replaceNthItem(spacing_Tables:,$spacing_table_index, $new_spacing_table);
  StoreValue($updated_spacing_tables, self:, spacing_tables);
	0;
};

