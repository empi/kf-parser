#! UG/KF 19.0
#
defclass: swd_funcs();


# #####################################################################################################

Defun: swd_askXYBoundingBoxList (
#+
DesignLogic=yes
-------------------------------------------------------------------------------
Description:
#.
Provides the same functionality as swd_askXYBoundingBox, except that it accepts a list of lists of points.
.#
Example:
(List) box: swd_askXYBoundingBoxList({{p(4,1,1), p(1,0,0), p(5,2,2), p(23,5,5)}, {p(12,10,1), p(20,0,0), p(222,2,4), p(22,2,5)}, {p(23,1,2), p(10,1,1), p(90,2,2), p(9,5,5)}});
-------------------------------------------------------------------------------
#-
List $pointListList #.list of list of point.#
)

@{	
	swd_askXYBoundingBox(	flatten( loop {
		for $thelist in $pointListList;
		collect swd_askXYBoundingBox($thelist);
	}));   
} List;
#+
-------------------------------------------------------------------------------
Returns:
List - #.List of points that form the containing box.#
-------------------------------------------------------------------------------
#-


# ####################################################################################################

Defun: swd_askXYBoundingBox(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
returns {Point(minimalXCoord,minimalYCoord, 0),Point(maximalXCoord, maximalYCoord, 0) }
.#
#-
List $pointList #.list of point.#
)

@{
   
	$Xs << loop{
		for $p in $pointList;
	    collect localx($p);		   			
	};
	$Ys <<  loop{
		   for $p in $pointList;
		   collect localy($p);		   	
	};	
	{Point(minList($Xs), minList($Ys), 0), Point(maxList($Xs), maxList($Ys), 0)};
} List;
#+
-------------------------------------------------------------------------------
Returns:
List - #.List of points that form the containing box.#
-------------------------------------------------------------------------------
#-



# #####################################################################################################

# #####################################################################################################

Defun: swd_installedFonts(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
Returns the list of fonts installed.
This list gets generated by reading a file called swd_font_index.dat.
This file may exist in two locations, a shared font directory and a personal font directory.
the environment variables KITE_SWD_FONTS_DIR and  KITE_SWD_PERSONAL_FONTS_DIR
if a font pops up in both lists (e.g. arial_bold.prt is listed in both swd_font_index.dat files),
the shared font entry will be silently discarded. .#
Example:
(List) fonts: swd_installedFonts();
-------------------------------------------------------------------------------
#-
)

@{  
  $shared_dir << getenv("KITE_SWD_FONTS_DIR");
	$shared_font_list << if(length($shared_dir) == 0) then {} else swd_readFontDir($shared_dir);
	$personal_dir << getenv("KITE_SWD_PERSONAL_FONTS_DIR");
	$personal_font_list << if(length($personal_dir) == 0) then {} else swd_readFontDir($personal_dir);
  # now make sure to get rid of fonts that are in both personal and shared dir
	#	personal takes precedence
	# both individual list are assumed to not contain any dupes.
	$personal_part_names << loop {
		for $line in $personal_font_list;
		collect last($line);
	};
 $filtered_shared_font_list << loop {
	 for $line in $shared_font_list;
	 if ! member(last($line), $personal_part_names )collect $line;
 };
	$personal_font_list + $filtered_shared_font_list;
} List;
#+
-------------------------------------------------------------------------------
Returns:
List - #.List of intalled fonts (list of strings).#
-------------------------------------------------------------------------------
#-

# #####################################################################################################

defun: swd_readFontDir(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
Reads a swd_font_index.dat file from the specified directory.
See swd_installedFonts(); .#
Example:
(List) fonts: swd_readFontDir(getEnv("SWD_KITE_FONTS_DIR"));
-------------------------------------------------------------------------------
#-
	String $font_dir 	   #.directory that contains the swd_font_index.dat and font partfiles.#
)
@{  
  $file_index_path << $font_dir + "\swd_font_index.dat";  
  $may_access? << Access($file_index_path, READ);
  $first_file_data << if($may_access?) then @{
    $file_descr << openFile($file_index_path, READ);	 
    $data << readSimpleDataFile($file_descr);
    $close_ok << closeFile($file_descr);   # TODO close ok testing
    loop {
			for $line in $data;
			collect  {$font_dir + "\" + first($line)} + Rest($line) +{first($line)};
		};
    } else 
    @{ 
			ug_printMessage( {"File not found or unreadable!", "Could not open file " + $file_index_path +"."});
      ug_error( " ERROR File not found or unreadable!", "Could not open file " + $file_index_path +".");
			{};
    };
} List;
#+
-------------------------------------------------------------------------------
Returns:
List - #.List of font names in this particular font directory.#
-------------------------------------------------------------------------------
#-

defun: swd_getUID(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
Returns a Java generated Unique ID. .#
Example:
(String) fonts: swd_getUID();
-------------------------------------------------------------------------------
#-
)
@{
 java_exec("de.conti.tires.kite.swd.helpers.instanceIDs.UID", "getUID", {});
}String;
#+
-------------------------------------------------------------------------------
Returns:
String - #.an Unique Identifier.#
-------------------------------------------------------------------------------
#-


defun: swd_isMinusOne(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
Test whether the argument equals to -1.

looks WTF-ish, I know, but removeIf for lists expects a function, and doesn't accept expressions
.#
Example:
(list) filtered_list: removeIf( swd_isMinusOne , list:) 
-------------------------------------------------------------------------------
#-
Integer $nmbr #. number to test.#
)
@{
	$nmbr = -1;
} boolean;
#+
-------------------------------------------------------------------------------
Returns:
Boolean - #.True if parameter equals -1, false otherwise..#
-------------------------------------------------------------------------------
#-




defun: swd_openPart(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
Opens a part file.
.#
Example:
(Int) open_success: swd_openPart("C:/build_a_nuke_from_household_appliances.prt");
-------------------------------------------------------------------------------
#-
String $partname #. name of file to open .#
)
@{
	java_exec("de.conti.tires.kite.common.NXJAVA", "openPartFile", {$partname} );
} Integer;
#+
-------------------------------------------------------------------------------
Returns:
Int - #.0 ~ success, everything else fail..#
-------------------------------------------------------------------------------
#-


defun: swd_askRadius(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
returns the value for circle_Radius or a default value if undefined.
.#
Example:
(Number) radius: swd_askRadius($constraints);
-------------------------------------------------------------------------------
#-
List $constraints #.Hash-like List of glyph/curve data.#
)
@{
	$circle_radius << com_askHashValue( "circle_radius", $constraints );				
	if($circle_radius = NoValue) then 600 / (2* pi()) else $circle_radius; # maybe better to return 0?
} Number;
#+
-------------------------------------------------------------------------------
Returns:
Number - #.value of 'circle_Radius' or a default value if 'circle_radius' is not set. .#
-------------------------------------------------------------------------------
#-




defun: swd_askOffsetAngle(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
asks the value of 'angular_offset'.
.#
Example:
$offset << swd_askOffsetAngle($constraints)
-------------------------------------------------------------------------------
#-
List $constraints #.Hash-like List of glyph/curve data.#
)
@{
	$offset_angle << com_askHashValue( "angular_offset", $constraints );				
	if($offset_angle = NoValue) then 
		@{ 
			0;} 
	else
	  @{ 
			 $offset_angle;
  	};
} Number;
#+
-------------------------------------------------------------------------------
Returns:
Number - #.value of 'angular_offset' or a suitable default value if  not set. .#
-------------------------------------------------------------------------------
#-

defun: swd_askArcCenter(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
asks the value of 'arc_center'.
.#
Example:
$offset << swd_askArcCenter($constraints)
-------------------------------------------------------------------------------
#-
List $constraints)
@{
		$arc_center << com_askHashValue( "arc_center", $constraints );
    if($arc_center = NoValue)	then Vector(0,0,0) else @{
			if(com_robustAskType($arc_center) = "Point" | 
			   com_robustAskType($arc_center) = "nx_point" |
				 com_robustAskType($arc_center) = "ug_point" )
			then com_Point2Vector($arc_center) else
			$arc_center;
		};
} Vector;
#+
-------------------------------------------------------------------------------
Returns:
Vector - #. vector that points to the center of the circle . .#
-------------------------------------------------------------------------------
#-


defun: swd_getLocalisedCurves(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
gets a collection of localised (translated to origin) curves/coordinates.
.#
Example:
$localised_curves << swd_getLocalisedCurves($font_ref, $glyph_indices);
-------------------------------------------------------------------------------
#-
String $font, #. absolute path to the font part file.#
List $glyph_indices #. charachter indices of text to layout.#
)
@{	
	$all_localised_curves << ug_askKFattrValue( $font, "swd_font:localised_curves");	
	debug_printValues({"swd_getLocalisedCurves", "all_localised_curves:", $all_localised_curves});
  $localised_curves << loop{
    for $glyph_index in $glyph_indices;
    collect nth($glyph_index,$all_localised_curves); 
  };
	$localised_curves;
} List;
#+
-------------------------------------------------------------------------------
Returns:
List - #.list of localised / not laid-out curves .#
-------------------------------------------------------------------------------
#-


defun: swd_getCurveTypes(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
collect the type of curves that make up the geometry for characters specified by glyph_indices.
.#
Example:
(List) curve_types: swd_getCurveTypes($font_ref, $indices);
-------------------------------------------------------------------------------
#-
String $font, 				#. absolute path to the font part file .#
List $glyph_indices   #. list of glyph indices .#
)
@{
    # get types of curves these points represent (first get all of them and then filter)  	
    $all_curve_types << ug_askKFattrValue( $font, "swd_font:curve_types");
    $curve_types << loop{
      for $glyph_index in $glyph_indices;
      collect nth($glyph_index,$all_curve_types); 
    };
		$curve_types;
} List;
#+
-------------------------------------------------------------------------------
Returns:
List  - #. list of list of strings (curve types) .#
-------------------------------------------------------------------------------
#-


defun:  swd_collectKnots(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
collects spline knots for the given characters.
.#
Example:
(List) knots: swd_collectKnots($font_ref, $indices);
-------------------------------------------------------------------------------
#-
String $font,							#. absolute path to the font part file .#
List $glyph_indices				#. indices of characters  .#
)
@{     
    # collect knots for splines
    $all_knots << ug_askKFattrValue( $font, "swd_font:spline_knots");
    $knots << loop{
      for $glyph_index in $glyph_indices;
      collect nth($glyph_index,$all_knots);
    };
		$knots;
} List;
#+
-------------------------------------------------------------------------------
Returns:
List - #. list of lists of knot data .#
-------------------------------------------------------------------------------
#-



defun: swd_getSplineDegrees(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
collects spline degrees for the given characters.
.#
Example:
(List) spline_Degrees: swd_getSplineDegrees($font_ref, $indices);
-------------------------------------------------------------------------------
#-
String $font,							#. absolute path to the font part file .#
List $glyph_indices				#. indices of characters  .#
)
@{  
    $all_spline_degrees << ug_askKFattrValue( $font, "swd_font:spline_degrees");
    $spline_degrees << loop{
      for $glyph_index in $glyph_indices;
      collect nth($glyph_index,$all_spline_degrees);
    };
}List;
#+
-------------------------------------------------------------------------------
Returns:
List - #. list of lists of degrees .#
-------------------------------------------------------------------------------
#-



defun: swd_sortLineData(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
sorts several hash-like lists of layout curve data into one hash-like list.
.#
Example:
(List) curves: swd_sortLineData($multi_line);
-------------------------------------------------------------------------------
#-
List $collected_line_data	#. list of list of curve data.#
)
@{
	$curve_types <<	loop {
    for $line_data in $collected_line_data;
    append com_askHashValue("curve_types", $line_data);
  };

  $laid_out_curves <<	loop {
    for $line_data in $collected_line_data;
    append  com_askHashValue("laid_out_curves", $line_data);
  };
  $knots <<	loop {
    for $line_data in $collected_line_data;
    append com_askHashValue("knots", $line_data);
  };
  $spline_degrees <<	loop {
    for $line_data in $collected_line_data;
    append com_askHashValue("spline_degrees", $line_data);
  };

  $sorted_data << { {"curve_types",$curve_types},
    {"laid_out_curves", $laid_out_curves }, 
    {"knots", $knots},
    {"spline_degrees", $spline_degrees}
  };

  $sorted_data;
} List;
#+
-------------------------------------------------------------------------------
Returns:
List - #. hash-like list of curve.#
-------------------------------------------------------------------------------
#-


defun:  swd_getSpacingsForText(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
collects spline knots for the given characters.
.#
Example:
$spacings <<  swd_getSpacingsForText($font_ref, "Continental", 1.0);
-------------------------------------------------------------------------------
#-
String $font,
String $text,
Number $spacing_factor,
Integer ($spacing_table_index, 1))
@{
    $indices << swd_askTokenIndices_kf( $text);
    $spacing_tables << ug_askKFattrValue($font, "swd_font:spacing_tables");
    swd_getSpacingsForIndices($spacing_tables, $indices, $spacing_factor, "spacing_table_index", $spacing_table_index);		
	} List;



defun: swd_askTokenIndices_kf(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
collects spline knots for the given characters.
.#
Example:
(List) indices: swd_askTokenIndices_kf("Spocht Contact");
-------------------------------------------------------------------------------
#-

String $the_text				#. text to break up and convert to indices .#
)
@{
# way too complicated for this simple functionality
# but KF simply makes me jump through hoops
# damn you, KF, damn you!!
# from my office I stab at thee!
	$ascii_offset << 31; # we start at ' ' which has ASCII code 32 and is on position 1 in our counting
	$special_char_offset << 96;
  $at_sign_ascii << ascii("@");
	$special_index_offset << ascii("0");
	$last_special_index << ascii("9");
	$indices <<	loop {
		for $char_pos from 1 to length($the_text);
		for $current_pos is $char_pos;
		for $current_char is substring($the_text, $char_pos, $char_pos);
		for $next_char is substring($the_text, $char_pos +1, $char_pos +1);
		for $current_ascii is ASCII($current_char);
  	for $next_ascii is ASCII($next_char);
		for $tmp_pos is if $current_ascii = $at_sign_ascii then $char_pos + 1 else $char_pos; #we have found an @, now focus on next character
		for $char_pos is $tmp_pos;
		collect @{
			if($current_ascii != $at_sign_ascii )
			then $current_ascii - $ascii_offset # we got a regular character 
			else 
			@{ # we got a special char, figure out which one we're talking about
				if($next_ascii == $at_sign_ascii) then $at_sign_ascii - $ascii_offset else # it was '@@' so return '@'
				if($next_ascii >= $special_index_offset && $next_ascii <= $last_special_index) then # one of "@0"..."@9"
          $special_char_offset + $next_ascii - $special_index_offset 
        else @{ # woops, we got something that is neither here nor there
					debug_printValues({"$current_pos", $current_pos});
          $title << "illegal special character sequence";
          $message << "String '" + $the_text +"' contains illegal character sequence '" + substring($the_text, $char_pos -1, $char_pos) + "'";
          ug_printMessage({$title, $message});
          ug_error($title, $message);
				};				 				
			};
    };
  };
} List;


defun:  swd_getWidthsForIndices(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
returns a list of width measures for a given text (as represented by the token indices)
.#
Example:
(List) widths: swd_getWidthsForIndices(original_constraints:);
-------------------------------------------------------------------------------
#-
String $font, #. name of the font part file to use.#
List $indices #. list of indices of characters .#
)
@{
  	$width_table << ug_askKFattrValue($font, "swd_font:width_table");
		$widths << loop {
      for $index in $indices;
      collect nth($index , $width_table);
    };
    $widths;
	} List;



defun: swd_getSpacingsForIndices(
#+
DesignLogic=yes
-------------------------------------------------------------------------------
Description:
#.
Returns a list of numbers that determine the spacing between individual characters.
.#
Example:
(List) swd_getSpacingsForIndices: swd_getNewConstraints({{A,2,3,4,5,56,1,0}, {B,1234,234,34,466}}, {64, 62,61}, 1.2);
-------------------------------------------------------------------------------
#-

List $spacing_tables, 							#. the list of spacign tables as provided by the font part..#
List $indices, 											#. list of character indices whose spacing should be computed .#
Number $spacing_factor,							#. list of character indices whose spacing should be computed .#
Integer ($spacing_table_index, 1) 	#. which spacing table should be used (if there are several) .#
	)
@{	
	if( empty?($spacing_tables) | $spacing_table_index > length($spacing_tables )) then @{
		debug_printValues({"spacing table is empty or table index to large"});
		debug_printValues({"index: ", $spacing_table_index, "spacing_tables size ", length($spacing_tables)});		
		{};
	} else @{
		$charspacings_and_linespacing << nth($spacing_table_index, $spacing_tables);
		$char_spacings << first($charspacings_and_linespacing);
		$spacings << Loop{
		  # loop counter till the second-to-last since we always use the element at index and at index +1
		  for $indexCounter from 1 to length($indices) - 1;
		  for $lhs is nth($indexCounter, $indices);
		  for $rhs is nth($indexCounter + 1, $indices);
		  # get all spacings for the left hand side
		  for $spacings_for_char is nth($lhs, $char_spacings);
			for $spacing is nth($rhs, $spacings_for_char);
		  # get the correct one for (lhs, rhs) combination
		  collect nth($rhs, $spacings_for_char) * $spacing_factor;
		};
		$spacings;
	};	
} List ;





defun: swd_computeHeight(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
computes the absolute height for the specified text.
This does not have to be the minimal-sized bounding box
but follows the SWL box model.
.#
Example:
	height: swd_computeHeight($constraints);
-------------------------------------------------------------------------------
#-
List $constraints #. hashy list of layout specs .#
)
@{
  # height:= height_of_line * number_of_lines + height_of_line_spacing * number_of_spacing =
  # number_of_lines * font_size + (number_of_lines -1) * line_spacing * line_spacing_factor

  $text << com_askHashValue("text", $constraints);
  $lines << SplitString($text, "~n");
  $nbr_of_lines << length($lines);

  # ask font for the appropriate line spacing value
	$font << com_askHashValue("font", $constraints);
	$spacing_tables << ug_askKFattrValue($font, "swd_font:spacing_tables");
	$spacing_table_index << com_askHashValue("spacing_table_index", $constraints);
	$default_line_spacing << second(nth($spacing_table_index, $spacing_tables)); # normed for 100 mm
	$font_size << com_askHashValue("font_size", $constraints);
  $line_spacing_factor << com_askHashValue("line_spacing_factor", $constraints);
	
	$line_spacing << $default_line_spacing * $font_size / swd_defaultFontHeight() * $line_spacing_factor;
		
	$height << $nbr_of_lines * $font_size + ($nbr_of_lines - 1 ) * $line_Spacing;
} Number;
#+
-------------------------------------------------------------------------------
Returns:
Number - #. height of block of text, in mm .#
-------------------------------------------------------------------------------
#-


defun: swd_computeLineWidth(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
computes the absolute length for the specified text. See swd_computeWidth
.#
Example:
$width<< swd_computeLineWidth("the text", "d:\my_arial.prt", 42.23, 1.0, 1);
-------------------------------------------------------------------------------
#-
		String $line,
		String $font_ref, 
		Number $font_size, 
		Number $spacing_factor, 
		Integer $spacing_table_index 
	)
@{
	$token_indices << swd_askTokenIndices_kf($line);
	$widths << swd_getWidthsForIndices($font_ref, $token_indices); 
	$spacings << swd_getSpacingsForText( $font_ref , $line, $spacing_factor, "spacing_table_index", $spacing_table_index );
	$widths_sum << loop {
			for $w in $widths;
			sum $w;
	};
  $spacings_sum<<loop {
    for $s in $spacings;
    sum $s;
  };
	($spacings_sum + $widths_sum) * $font_size/ swd_defaultFontHeight();
}Number;
#+
-------------------------------------------------------------------------------
Returns:
Number - #. width of line of text in mm.#
-------------------------------------------------------------------------------
#-

defun: swd_computeWidth(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
computes the absolute width for the specified text.
may be multi-line text.
This does not have to be the minimal-sized bounding box
but follows the SWL box model. (spacings + widths, which do _not_ have to be the
same as actual geometry size)
.#
Example:
$line_width: swd_computeWidth($constraint_for_lines);
-------------------------------------------------------------------------------
#-
List $constraints #. hashy list of layout options .#
)
@{
  # widht of block: max(width_of_lines)
	# widht of line: sum(widht(character))+sum(spacing(character, character))

  $text << com_askHashValue("text", $constraints);
  $lines << SplitString($text, "~n");
	$font_ref << com_askHashValue("font", $constraints);
	$spacing_Factor << com_askHashValue("spacing_factor", $constraints);
	$spacing_table_index << com_askHashValue("spacing_table_index", $constraints);
	$font_size << com_askHashValue("font_size", $constraints);
	$width << loop {
		for $line in $lines;
		max_of swd_computeLineWidth($line, $font_ref, $font_size, $spacing_factor, $spacing_table_index);
	};
	$width;
} Number;
#+
-------------------------------------------------------------------------------
Returns:
Number - #. width of the longest line of this block of text, in mm .#
-------------------------------------------------------------------------------
#-

defun: swd_isAnchorBottom(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
tests whether the anchor option contained 'Bottom' 
.#
Example:
if( swd_isAnchorBottom($constraints)) then ...;
-------------------------------------------------------------------------------
#-
List $constraints #. hash-y list of constraints .#
)
@{
	$anchor << com_askHashValue("anchor_method", $constraints);
	$is_bottom? << $anchor = "Bottom Left" | $anchor = "Bottom Center" | $anchor = "Bottom Right" ;	
	$is_bottom?;
}; Boolean;
#+
-------------------------------------------------------------------------------
Returns:
Boolean - #. whether the anchor option contained 'Bottom' .#
-------------------------------------------------------------------------------
#-

defun: swd_isAnchorMiddle(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
tests whether the anchor option contained 'Middle' 
.#
Example:
if( swd_isAnchorMiddle($constraints)) then ...;
-------------------------------------------------------------------------------
#-
List $constraints #. hash-y list of constraints .#
)
@{
	$anchor << com_askHashValue("anchor_method", $constraints);
	$is_middle? << $anchor = "Middle Left" | $anchor = "Middle Center" | $anchor = "Middle Right" ;
	$is_middle?;
}; Boolean;
#+
-------------------------------------------------------------------------------
Returns:
Boolean - #. whether the anchor option contained 'Middle' .#
-------------------------------------------------------------------------------
#-


defun: swd_isAnchorTop(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
tests whether the anchor option contained 'Top' 
.#
Example:
if( swd_isAnchorTop($constraints)) then ...;
-------------------------------------------------------------------------------
#-
List $constraints #. hash-y list of constraints .#
)
@{
	$anchor << com_askHashValue("anchor_method", $constraints);
	$is_top? << $anchor = "Top Left" | $anchor = "Top Center" | $anchor = "Top Right" ;
	$is_top?;
}; Boolean;
#+
-------------------------------------------------------------------------------
Returns:
Boolean - #. whether the anchor option contained 'Top' .#
-------------------------------------------------------------------------------
#-

defun: swd_isAnchorLeft(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
tests whether the anchor option contained 'Left' 
.#
Example:
if( swd_isAnchorLeft($constraints)) then ...;
-------------------------------------------------------------------------------
#-
List $constraints #. hash-y list of constraints .#
)
@{
	$anchor << com_askHashValue("anchor_method", $constraints);
	$is_left? << $anchor = "Top Left" | $anchor = "Middle Left" | $anchor = "Bottom Left" ;
	$is_left?;
}; Boolean;
#+
-------------------------------------------------------------------------------
Returns:
Boolean - #. whether the anchor option contained 'Left' .#
-------------------------------------------------------------------------------
#-


defun: swd_isAnchorCenter(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
tests whether the anchor option contained 'Left' 
.#
Example:
if( swd_isAnchorCenter($constraints)) then ...;
-------------------------------------------------------------------------------
#-
List $constraints #. hash-y list of constraints .#
)
@{
	$anchor << com_askHashValue("anchor_method", $constraints);
	$is_center? << $anchor = "Top Center" | $anchor = "Middle Center" | $anchor = "Bottom Center" ;
	$is_center?;
}; Boolean;
#+
-------------------------------------------------------------------------------
Returns:
Boolean - #. whether the anchor option contained 'Center' .#
-------------------------------------------------------------------------------
#-


defun: swd_isAnchorRight(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
tests whether the anchor option contained 'Right' 
.#
Example:
if( swd_isAnchorRight($constraints)) then ...;
-------------------------------------------------------------------------------
#-
List $constraints #. hash-y list of constraints .#
)
@{
	$anchor << com_askHashValue("anchor_method", $constraints);
	$is_right? << $anchor = "Top Right" | $anchor = "Middle Right" | $anchor = "Bottom Right" ;
	$is_right?;
}; Boolean;
#+
-------------------------------------------------------------------------------
Returns:
Boolean - #. whether the anchor option contained 'Right' .#
-------------------------------------------------------------------------------
#-


defun: swd_createMultiConstraints(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
 creates a one set of constraints per line of text
.#
;
-------------------------------------------------------------------------------
#-
	List $original_constraints #. original constraints .#
	)
@{
	# just dispatches to the strategy appropriate function
	$strategy << com_askHashValue("layout_strategy", $original_constraints);
	if $strategy = Circle then swd_createMultiConstraintsCircle($original_constraints) else 
	if $strategy = StraightLine then swd_createMultiConstraintsStraight($original_constraints) else
	@{	
		debug_printValues({"unknown strategy: ", $strategy});
		{};
	};
}List;
#+
-------------------------------------------------------------------------------
Returns:
List - #.List of constraints, one per line of text..#
-------------------------------------------------------------------------------
#-


defun: swd_createMultiConstraintsStraight(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
 creates a one set of constraints per line of text for straight layout strategy
.#
;
-------------------------------------------------------------------------------
#-
	List $original_constraints #. original set of constraints .ä
)
@{
	# grab needed data
	$lines << com_askHashValue("lines", $original_constraints);
	$nbr_of_lines << length($lines);
	$anchor << com_askHashValue("anchor_method", $original_constraints);
	$line_spacing_factor << com_askHashValue("line_spacing_factor", $original_constraints);
  $spacing_table_index << com_askHashValue("spacing_table_index", $original_constraints);
	$spacing_factor << com_askHashValue("spacing_factor", $original_constraints);
	$font << com_askHashValue("font", $original_constraints);
	$spacing_tables << ug_askKFattrValue($font, "swd_font:spacing_tables");
	$default_line_spacing << second(nth($spacing_table_index, $spacing_tables)); # normed for 100 mm
	$font_size << com_askHashValue("font_size", $original_constraints);
	$line_spacing << $default_line_spacing * $font_size / swd_defaultFontHeight() * $line_spacing_factor;
	$rotation_angle << com_askHashValue("rotation_angle", $original_constraints);
  $start_point << com_askHashValue("start_point", $original_constraints);	
	$cleaned_constraints << com_filterHashEntries({"start_point" }, $original_constraints);
	$block_width << swd_computeWidth($original_constraints);
	$block_height << swd_computeHeight($original_constraints);	
  $constraints_per_line << loop {
    for $line_idx from 1 to length($lines);	
    for $line in $lines;
    for $line_distance is ($line_idx - 1) * ($line_spacing + $font_size);
    
    # rotate Z vector around X axis by $rotation_angle
    for $rot_vec_vertical is unitize(rotateVector(Vector(0,0,1), $rotation_angle, Vector(1,0,0)));
    # rotate Y vector around X axis by $rotation_angle
    for $rot_vec_horizontal is unitize(rotateVector(Vector(0,1,0), $rotation_angle, Vector(1,0,0)));
    
    # bottom: do nothing for single line ($nbr_lines - $line_idx => 0), else move up by the height of all lines that will follow
    # middle: move line up by half the complete block heigth, then down by the height of all previous lines
    # top: move line up by complete block height, then down by the height of all previous lines
    for $vertical_anchor_vec is if swd_isAnchorBottom($original_constraints) then $rot_vec_vertical *  ($nbr_of_lines - $line_idx) * ($font_size + $line_spacing)  else 
                    if swd_isAnchorMiddle($original_constraints) then  $rot_vec_vertical *  ($block_height /2 - ($font_size * $line_idx) - ($line_Spacing * ($line_idx -1 ))) else
                    if swd_isAnchorTop($original_constraints) then $rot_vec_vertical *  -1 *($block_height  - ($nbr_of_lines - $line_idx) * ($font_size + $line_spacing))  else @{
                       # failed to identify strategy
											 $anchor_method << com_askHashValue("anchor_method", $original_constraints);
                        debug_printValues({"unknown anchor method:", $anchor_method});
                        Vector(0,0,0);
                    };
    
    # left: do nothing 
    # center: move by half the block width
    # right: move by block width
    for $horizontal_anchor_vec is  if swd_isAnchorLeft($original_constraints) then Vector(0,0,0) else 
                    if swd_isAnchorCenter($original_constraints) then $rot_vec_horizontal*- 0.5 * $block_width else
                    if swd_isAnchorRight($original_constraints) then $rot_vec_horizontal* - $block_width else @{
                       # failed to identify strategy
                        $anchor_method << com_askHashValue("anchor_method", $original_constraints);
                        debug_printValues({"unknown anchor method:", $original_constraints});
                        Vector(0,0,0);
                    };    
    for $new_start_point is $start_point + $vertical_anchor_vec + $horizontal_anchor_vec;
		# does not modify $cleaned_constraints    
    collect $cleaned_constraints + {{"line", $line}, {"start_point", $new_start_point}};
  };
} List;
#+
-------------------------------------------------------------------------------
Returns:
List - #.List of constraints, one per line of text..#
-------------------------------------------------------------------------------
#-


defun: swd_createMultiConstraintsCircle(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
 creates a one set of constraints per line of text for circle layout strategy
.#
;
-------------------------------------------------------------------------------
#-
	List $constraints #. original constraints .#
)
@{
	#	gather required data
	$lines << com_askHashValue("lines", $constraints);
	$nbr_of_lines << length($lines);
	$anchor << com_askHashValue("anchor_method", $constraints);
	$line_spacing_factor << com_askHashValue("line_spacing_factor", $constraints);
  $spacing_table_index << com_askHashValue("spacing_table_index", $constraints);
	$spacing_factor << com_askHashValue("spacing_factor", $constraints);
	$font << com_askHashValue("font", $constraints);
	$spacing_tables << ug_askKFattrValue($font, "swd_font:spacing_tables");
	$default_line_spacing << second(nth($spacing_table_index, $spacing_tables)); # normed for 100 mm
	$font_size << com_askHashValue("font_size", $constraints);	
	$line_spacing << $default_line_spacing * $font_size / swd_defaultFontHeight() * $line_spacing_factor;
	$circle_radius << com_askHashValue("circle_Radius", $constraints);
	$base_angular_offset << com_askHashValue("angular_offset", $constraints);
	$cleaned_constraints << com_filterHashEntries({"angular_offset", "circle_radius"}, $constraints);
	$block_height << swd_computeHeight($constraints);	
	# start computing
	$constraints_per_line << loop {
		for $line_idx from 1 to length($lines);	
		for $line in $lines;
		for $line_distance is ($line_idx - 1) * ($line_spacing + $font_size);

		for $line_width is swd_computeLineWidth($line, $font, $font_size, $spacing_factor, $spacing_table_index);

    # bottom: do nothing for single line ($nbr_lines - $lines => 0), else 
		#					increase by height of all 'additional' (lines 2...n) lines, then decrease by distance of this particular line ... kinda tricky, this one
		#					note: mix of line_spacing and line_distance is intentional, though somewhat confusing
    # middle: decrease by distance of this particular line, then increase by height of 'additional' lines 
    # top: move line up by complete block height, then down by the height of all previous lines
		for $new_radius is  if swd_isAnchorBottom($constraints) then ($circle_radius  - $line_distance) + ($nbr_of_lines -1) * ($font_size + $line_spacing) else
												if swd_isAnchorMiddle($constraints) then ( $circle_radius   - $line_distance) + ($block_height/2 -$font_size) else
												if swd_isAnchorTop($constraints) then $circle_radius  - $line_distance - $font_size  else @{
													# epic anchor fail
													$anchor_method << com_askHashValue("anchor_method", $constraints);
													debug_printValues({"unknown anchor method:", $anchor_method});
													$circle_radius - $line_distance;
												};
		for $angle is com_arcCentralAngle($new_radius, $line_width);
		for $new_angular_offset is if swd_isAnchorLeft($constraints) then $base_angular_offset else 
												 if swd_isAnchorCenter($constraints) then NormalizeAngle($base_angular_offset + 0.5 * $angle )else
												 if swd_isAnchorRight($constraints) then NormalizeAngle($base_angular_offset + $angle) else @{
                            # I dunno what anchor you gave
                            $anchor_method << com_askHashValue("anchor_method", $constraints);
                            debug_printValues({"unknown anchor method:", $anchor_method});
                            $base_angular_offset;
												 };		
		collect $cleaned_constraints + {{"angular_offset", $new_angular_offset}, {"circle_radius", $new_radius}, {"line", $line}};
	};
} List;


Defun: swd_computeFontSizeFromAngleRange(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
	uses circle radius and angle range to compute a font size.
.#
;
-------------------------------------------------------------------------------
#-
	List $constraints #. .#
)
@{
	# layout once, using the font size the user provided (which is swd_defaultFontHeight() if not changed)
	# see how large the angle is that the text covers
	# compare it with the desired angle
	# scale font_size accordingly.
	$desired_angle_range << com_askHashValue("angle_Range", $constraints);
	$font_size << com_askHashValue("font_size", $constraints);
	$width << swd_computeWidth($constraints);
	$radius << swd_askRadius($constraints);
  $circumference << com_arcLength($radius, 360);
	# if width > circumference, angle computation will fail,
	# so let's break it down to manageable level before	
	$loop_limit << 1000; # kinda arbitrary upper limit
	$factors << loop {
		for $i from 1 to $loop_limit; 
		for $factor is $i ^ 2;
		for $i is if ($width / $factor < $circumference ) then $loop_limit else $i; # poor man's while loop
		collect $factor;
	};	
	$factor << last($factors);
	$real_angle_Range << com_arcCentralAngle($radius, $width / $factor);	
	$new_font_size << ($desired_angle_Range * $font_size) /($real_angle_range * $factor);	
	$new_font_size;
} Number;
#+
-------------------------------------------------------------------------------
Returns:
Number - #.font size in mm .#
-------------------------------------------------------------------------------
#-

Defun: swd_computeFontSizeFromExtent(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
	computes the font size so the text fits a given extent /'running length'.
.#
;
-------------------------------------------------------------------------------
#-
	List $constraints #. layout constraints .#
	)
@{
	# layout once, using the font size the user provided (which is swd_defaultFontHeight() if not changed) and
	# measure how wide it is
	# compare it with the desired extent
	# scale to fit the desired extent
	$extent << com_askHashValue("extent", $constraints);
	$font_size << com_askHashValue("font_size", $constraints);
	$width << swd_computeWidth($constraints);
	$extent/$width * $font_size;	
} Number;
#+
-------------------------------------------------------------------------------
Returns:
Number - #.font size in mm .#
-------------------------------------------------------------------------------
#-

Defun: swd_normalizeSizeConstraints(
#+
DesignLogic=yes
-------------------------------------------------------------------------------
Description:
#.
converts font_size constraint by extent or angle range to size constraint by font_size.
In other words, given a font, a text, and an extent or angle range, computes the appropriate font_size.
.#
Example:
(List) $size_normalized_constraints: swd_normalizeSizeConstraints($constraints);
-------------------------------------------------------------------------------
#-
	List $constraints		#. original constraints.#
)
@{
	$size_constraint_by << com_askHashValue("size_constraint", $constraints);
	if($size_constraint_by = "font size") then $constraints else if ($size_constraint_by = "angle range") then
	@{
		$font_size << swd_computeFontSizeFromAngleRange($constraints);
		com_filterHashEntries({"font_size"}, $constraints) + {{"font_size", $font_size}};
	} else if($size_constraint_by = "extent") then @{
    $font_size << swd_computeFontSizeFromExtent($constraints);
		com_filterHashEntries({"font_size"}, $constraints) + {{"font_size", $font_size}};
	}
  else@{ 
		debug_printValues({"size constraint not known:", $size_constraint_by});
		{}; # return an empty list
		};
}List;
#+
-------------------------------------------------------------------------------
Returns:
List - #. whether the anchor option contained 'Right' .#
-------------------------------------------------------------------------------
#-


defun: swd_reverseTextIfNeeded(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
	when upside_down drawin is toggled on, the text needs to be reversed.
	this function does exactly that.
.#
;
-------------------------------------------------------------------------------
#-
	List $constraints #. layout parameters .#
)
@{
	$upside_down? << com_askhashvalue("upside_down?", $constraints);
	if($upside_down?) then @{
    $text << com_askHashValue("text", $constraints);
		# revert order of lines (multi line text)
    $lines << reverse(splitString($text, "~n"));
		# reverse each line itself
    $reverted_lines << loop {
      for $line in $lines;
			collect swd_reverseLine($line);
    };
		$filtered_constraints << com_filterHashEntries({"lines"}, $constraints) + {{"lines", $reverted_lines}};
	} else $constraints;

}List;


defun: swd_mirrorCurvesIfNeeded(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
	flip curve geometry if upside_down has been switched on.
.#
;
-------------------------------------------------------------------------------
#-

	List $constraints, 			#. geometry parameters .#
	List $localised_curves  #. geometry .#
	)
@{
	debug_printValues({"begin swd_mirrorCurvesIfNeeded"});
	$upside_down? << com_askhashvalue("upside_down?", $constraints);
	$return << if($upside_down?) then @{
    loop{
			for $curve_list in $localised_curves;
			collect loop{
				for $curve in $curve_list;
				collect loop{
					for $p in $curve;
					collect Point(-localx($p), swd_defaultFontHeight() - localy($p), 0); # flip it
				};				
			};
		};
	} else $localised_curves;		
	debug_printValues({"end swd_mirrorCurvesIfNeeded"});	
	$return;
} List;
#+ 
#-





defun: swd_layout(
#+
DesignLogic=no
-------------------------------------------------------------------------------
Description:
#.
Creates geometric data for drawing text.
.#
;
-------------------------------------------------------------------------------
#-
List $constraints #. hash like key value pairs of constraints .#
)
@{
	# open the part file
	$font_ref << com_askHashValue("font", $constraints );
	$great_succes << ug_openPart($font_ref);
  if($great_succes != 0) then @{ 
		ug_printValue("Could not open file " + $font_ref + "!");   
		{}; #poor mans 'null' 
	}
	else @{		
		$text << com_askHashValue("text", $constraints);
		# split into single lines
		$lines << SplitString($text, "~n");		
		$base_constraints <<  swd_reverseTextIfNeeded( swd_normalizeSizeConstraints($constraints) + {{"lines", $lines}});							

		##
		$one_constraint_per_line << swd_createMultiConstraints($base_constraints);
		###
		$spacing_factor << com_askHashValue("spacing_factor", $base_constraints );
		$spacing_table_index << com_askHashValue("spacing_table_index", $base_constraints );
		$font_size << com_askHashValue("font_size", $base_constraints );
    $glyph_collection << loop {
			for $line_constraints in $one_constraint_per_line;
			for $line is com_askHashValue("line", $line_constraints);
			
      collect @{        
        # ask for spacings for the text given (distances between pairs of characters)
        $spacings << swd_getSpacingsForText( $font_ref , $line, $spacing_factor, "spacing_table_index", $spacing_table_index );           
				
				# ask for positions of characters in the character map 
        $token_indices << swd_askTokenIndices_kf($line);
        
				# ask for character widths
        $widths << swd_getWidthsForIndices($font_ref, $token_indices);  
        debug_printValues({"vor mirror curves if needed."});
        $localised_curves << swd_mirrorCurvesIfNeeded($line_constraints, swd_getLocalisedCurves($font_ref, $token_indices));          
        debug_printValues({"nach mirror curves if needed."});
        $curve_types << swd_getCurveTypes($font_ref, $token_indices);
        $knots << swd_collectKnots($font_ref, $token_indices);   
        $spline_degrees << swd_getSplineDegrees($font_ref, $token_indices);	 
      
         { {"curve_types",$curve_types},
          {"localised_curves", $localised_curves }, 
          {"knots", $knots},
          {"spline_degrees", $spline_degrees},
					{"line_constraints", $line_constraints},
					{"spacings", $spacings},
					{"widths", $widths},
        };
      };
    }; # end loop

		$glyph_collection;
	  
  };
} List;
#+
-------------------------------------------------------------------------------
Returns:
List - #.Hash-like List of glyph/curve data.#
-------------------------------------------------------------------------------
#-

defun: swd_displayCharacterMap()
@{
	{ "<space>", "!", "~"", "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", "0", "1", "2", "3", "4", "5", "6", "7",
            "8", "9", ":", ";", "<", "=", ">", "?", "@", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N",
            "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "[", "\", "]", "^", "_", "`", "a", "b", "c", "d", "e",
            "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "{", "|", "}" ,
            Char(126),"@0", "@1", "@2", "@3", "@4", "@5", "@6", "@7", "@8", "@9"};
						# char(126) is a workaround due to KF string escape sequences not working properly
} List;


defun: swd_characterMap()
@{
	{ " ", "!", "~"", "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", "0", "1", "2", "3", "4", "5", "6", "7",
            "8", "9", ":", ";", "<", "=", ">", "?", "@@", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N",
            "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "[", "\", "]", "^", "_", "`", "a", "b", "c", "d", "e",
            "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "{", "|", "}" ,
            Char(126),"@0", "@1", "@2", "@3", "@4", "@5", "@6", "@7", "@8", "@9"};
						# char(126) is a workaround due to KF string escape sequences not working properly
} List;


defun: swd_reverseLine(String $text)
@{
	$token_indices << swd_askTokenIndices_kf($text);
	$token_indices_reverted << reverse($token_indices);
	$char_map << swd_characterMap();
	loop{
    with $new_text is "";
    for $character_idx in $token_indices_reverted;
    for $new_Text is $new_text + Nth($character_idx, $char_map);
    return is $new_text;
 };	
} String;

