#! NX/KF 5.0
# User Interface class for swd_text
DefClass: swd_ui_Text (%ui_comp %com_ui_actions);

# font path
(String Modifiable Parameter ) 	font_ref: "";

# text to draw; may contain special positions like '@1'
(String Modifiable Parameter )	text: "";


# currently there are two possible 
# values: Circle and StraightLine
(Name Modifiable Parameter ) 		layout_strategy_name: Circle;

# depending on layout_strategy, this may be the circle center point
# or line starting point.
(Point Modifiable Parameter  )	reference_point: Point(0,0,0);

# nominal font height in mm
# note that font_size: 50 does not have to result in a shape that is exactly
# 50mm high, since it also depends on how large the character has been drawn in the 
# font. If it has been drawn in 80mm (in the corresponding font part)
# a font size of 50 will result in a geometry that is 40 mm high
# (80mm) * (50mm/100mm)
(Number Modifiable Parameter ) 	font_size: 100.0;

# 'running length' of text
# used to automatically make the text fill a specified length
# in that case the font_size will be computed automatically
(Number Modifiable Parameter ) 	extent: 200; # kinda arbitrary default value

# analogue to extent, except it uses an angle the text should span over
# only makes sense iff layout_strategy: Circle 
(Number Modifiable Parameter ) 	angle_range: 90; # kinda arbitrary default value

# rotates the text position by the given degree
# only makes sense iff layout_strategy: Circle 
(Number Modifiable Parameter ) 	angular_offset: 0;

# distance of text to reference_point
# only defined for layout_strategy: Circle 
(Number Modifiable Parameter ) 	circle_radius: 500;

# rotates the text around reference_point by given degree
# only used when layout_strategy is StraightLine
(Number Modifiable Parameter ) 	rotation_angle: 0;

# which spacing table to use
(Integer Modifiable Parameter ) spacing_table_index: 0;

# modifies the spacing between characters by a factor
# the spacings between individual spacing pairs are
# defined in spacing tables contained in the font file
(Number Modifiable Parameter ) 	spacing_factor: 1.0;

# defines to  which part of the text  the selected position constraints are  in reference
# to. see available_anchor_methods: for an example and possible values.
(String Modifiable Parameter)		anchor_method: nth(8, available_anchor_methods: ); 

# only used in multi line text
# extra spreading factor between lines
# defined per font
(Number modifiable parameter) 	line_spacing_factor: 1.0;

# if true, puts the text on its head
# anchor methods keep their meaning
# i.e. the bottom_{left,center,right} will always mean the 
# line closest to the reference point
# or looking at it from the viewpoint of the character itself:
# this toggle swaps head- and base-line
(Boolean modifiable parameter)  upside_down?: false;

# distorts the geometry by an angle
# negative values will make the top narrower
# positive values will make the top wider
(Number Modifiable Parameter) 	pointing_angle: 0.0;

# distorts the geometry by an angle
# e.g. a horizontal and vertical line that usually form
# a ninety degree angle will form an eighty degree angle
# with shearing_angle: 10
(Number Modifiable Parameter) 	shearing_angle: 0.0;

# expands the geometry so it is flush with the circle
# i.e. extensions of usually vertical parallel lines  ( e.g. | |) of characters
# will now intersect at the arc center, 
# horizontal parralel lines will be bent
# only defined for layout_Strategy: circle
(Boolean modifiable parameter)  bow_expand?: false;

# flag to allow/prohibit actual geometry creation
# gets set to true if the UI has gathered sufficient data
(boolean Modifiable) 						ok_to_create_geom: false;

# humand readable name/description of the selected font
# this is currently used to figure out the position of currently selected
# fonts in the list of available fonts
# this is obviously pretty moronic since this is pretty certain to break under maintenance
# when font descriptions change - what the hell was I thinking? :-S Not much, it seems.
# TODO come up with a maintenance proof way to do it - me thinks some sort of unique, stable font 'primary key'/ID should
# do the trick -> use the unique part of the font name maybe
(String modifiable)							font_display_name: "";

# spacing table names, taken from the selected font
(List Modifiable)								spacing_table_descriptions: {};

# set of available layout_strategies
(List) 													layout_strategy_name_init: {  Circle, StraightLine};

# set of possible anchor methods.
# cartesian product of (top, middle, bottom} and {left, center, right}
# denotes vertical and horizontal reference for positioning constraints
# e.g. if radius = 250, offset_angle = 0, anchor_method: bottom_left
# the nominal base line of the text will be at a distance of 250 mm from the selected
# center point, and the left most boundary will be at 0 degrees.
(List)												 	available_anchor_methods: {
                                  "Top Left",  		"Top Center", 		"Top Right",
                                  "Middle Left",  "Middle Center", "Middle Right",
                                  "Bottom Left",  "Bottom Center", "Bottom Right"
                              	};

# default layoutstrategy is circle, so use those constraints as default															
(List)												 	available_size_constraints:available_size_constraints_circle:;

# ways to constrain the font size for layout_Strategy: circle
(List)												 	available_size_constraints_circle: {"font size", "extent",  "angle range"};

# ways to constrain the font size for layout_Strategy: straight
(List)												 	available_size_constraints_straight: {"font size",   "extent"};

# UI elements for size constraints; needed for dynamically building the UI depending on selectet
# constraint method
(List)													size_constraint_controls: {SelectFontSize:, SelectExtent:, SelectAngleRange: };

# selects the way font size is constrained
# see angle_range, font_size and extent in this class
(String modifiable Parameter) 	size_constrained_by: first(available_size_constraints:);

# layout constraints and geometry as computed by swd_layout()
(List modifiable)								layout:{};
			
# temporary storage for UI state
# only for debugging purposes
(List Modifiable parameter) 		constraints: {};
														

# list of available fonts as defined in font_index.dat
# list of {path: string, description: string) lists
(List) installed_fonts:				swd_installedFonts();

#
(List) installed_fonts_names:
loop {
	for $descr in installed_fonts:;
	collect second($descr);
};
	
	
# dialog items for ui
(list) DialogItems: 				{ 
															TitleImage:, TextGroup:, 
															SelectFontGroup: , PlacementGroup:, MogrifyGlyphsGroup:, 
															MetaDataGroup:, ActionGroup:  
														};


# this is to use the update toggle instead of an update button
(Boolean Parameter)				 use_update_toggle?: true;

(Child) TitleImage: {
  Class, 	%ui_comp_label;
	icon, 	"swd_font_editor";
};


## text
(Child) TextGroup: {
  Class, 		%ui_comp_group;
	title, 		"Text";
  members, 	{ TextEntry:, OpenMultiLineText: };
  Column, 	0;
  Group, 		true;
};


(Child) TextEntry:
{
  class,						 	%ui_comp_string;
  Title, 							"Text:";
  value, 							text:;
  PresentationStyle, 	1;
};


(Child) OpenMultiLineText: {
  Class, 							%ui_comp_button;
	title, 							"Enter Multi Line Text",
  ToolTipTitle, 			False;
  Tooltip, 						"Enter Multi Line Text";
};

### general / meta data
(Child) MetaDataGroup: {
  Class, 							%ui_comp_group;
	title, 							"Meta Data";
  members, 						{ PositionEntry:, DescriptionEntry:, RemarkEntry: };
  Column, 						0;
  Group, 							true;
};
(Child) PositionEntry:
{
  class, %ui_comp_string;
  Title, "Position Number:";
  value, meta_position:;
  PresentationStyle, 1;
};
(Child) RemarkEntry:
{
  class, %ui_comp_string;
  Title, "Remark:";
  value, meta_remark:;
  PresentationStyle, 1;
};

(Child) DescriptionEntry:
{
  class, %ui_comp_string;
  Title, "Description:";
  value, meta_description:;
  PresentationStyle, 1;
};


## font
(Child) SelectFontGroup: {
  Class, %ui_comp_group;
	title, "Font";
  members, { SelectFontList: };
  Column, 0;
  Group, true;
};


(Child) SelectFontList: {
  Class, %ui_comp_enum;
  title, "Select font:",
  PresentationStyle, 0;
  TitleVisibility, true;
  BorderVisibility, true;
  RadioOrientation, 0;
  Titles, installed_fonts_names: ; 
};



# text placement
(Child) PlacementGroup: {
  Class, %ui_comp_group;
	title, "Text Placement";
  members, { 	SelectLayoutStrategy:, SelectSizeConstraintMethod:, SelectFontSize:, SelectExtent:, SelectAngleRange:, SelectSpacingFactor:,  
							PlaceOnCircleGroup:, PlaceOnLineGroup:, 	SelectSpacingTable:, Anchors:, VisibleOnHalfLabel:, TopHalfToggle:, BottomHalfToggle:};
  Column, 0;
  Group, true;
};

(Child) VisibleOnHalfLabel: {
  Class, %ui_comp_label;
	title, "Visible on";
	topattach, Anchors:,
};

(Child) TopHalfToggle: {
  Class, %ui_comp_toggle;
	title, "top half",
	topattach, Anchors:,
	LeftAttach, VisibleOnHalfLabel:, 
  value, False;
};

(Child) BottomHalfToggle: {
  Class, %ui_comp_toggle;
	title, "bottom half",
	LeftAttach, TopHalfToggle:, 
	topattach, Anchors:,
  value, False;
};
(Child) SelectLayoutStrategy: {
  Class, %ui_comp_enum;
  title, "Select Layout Strategy";
  value, readStoredStrategyIndex:(); # UI and KF count differently
  PresentationStyle, 0;
  TitleVisibility, true;
  BorderVisibility, true;
  RadioOrientation, 0;
  Titles,{"Circle", "StraightLine" } ;
};


(Child) SelectSizeConstraintMethod: {
  Class, %ui_comp_enum;
  title, "Select size constraint by:",
  value, readStoredSizeConstraintIndex:(); 
  PresentationStyle, 0;
  TitleVisibility, true;
  BorderVisibility, true;
  RadioOrientation, 0;
  Titles, available_size_constraints: ; 
};		

(Child) SelectFontSize: {
  Class, %ui_comp_expression;
  value, font_size:;
  unit, "";
  title, "Size";
  MaximumValue, 1.0e19;
  MinimumValue, -1.0e19;
  Width, 0;
  VisibleDecimals, 4;
	Visibility, size_constrained_by: = "font size";
};



(Child) SelectExtent: {
  Class, %ui_comp_expression;
  value, extent:;
  unit, "mm";
  title, "Extent";
  MaximumValue, 1.0e19;
  MinimumValue, -1.0e19;
  Width, 0;
  VisibleDecimals, 4;
		Visibility, size_constrained_by: = "extent";
};


(Child) SelectAngleRange: {
  Class, %ui_comp_expression;
  value, angle_range:;
  units, "degrees",
  title, "Angle range";
  MaximumValue, 1.0e19;
  MinimumValue, -1.0e19;
  Width, 0;
  VisibleDecimals, 4;
	Visibility, size_constrained_by: = "angle range";
};



(Child) SelectSpacingFactor: {
  Class, %ui_comp_expression;
  value, spacing_factor:;
  units, "";
  title, "Enter Spacing Factor";
  MaximumValue, 1.0e19;
  MinimumValue, -1.0e19;
  Width, 0;
  VisibleDecimals, 4;
};


(Child) PlaceOnCircleGroup: {
  Class, %ui_comp_group;
  title, "Circle Placement Options";
  members, { 	SelectRadius:, SelectAngularOffset:, SelectCircleCenterPoint: };
  Column, 0;
  Group, true;
	Visibility, layout_strategy_name: = Circle
};


(Child) SelectRadius: {
  Class, %ui_comp_expression;
  title, "Circle Radius";
  value, circle_radius:;
  unit, "mm",
};


(Child) SelectAngularOffset: {
  Class, %ui_comp_expression;
  title, "Angular Offset";
  units, "degrees",
  value, angular_offset:;
};


(Child) SelectCircleCenterPoint: {
  Class, %ui_comp_point;
  Point,reference_point:;
  SoUpdateOption, 3;
  NoHandle, False;
  LabelString, "Circle Center Point";
  Scope, 1;
  GwifType, 0;
	Sensitivity, layout_strategy_name: = Circle;
};

(Child) PlaceOnLineGroup: {
  Class, %ui_comp_group;
  title, "Line Placement Options";
  members, { 	SelectRotationAngle:, SelectLineRefPoint: };
  Column, 0;
  Group, true;
  Visibility, layout_strategy_name: = StraightLine;
};


(Child) SelectRotationAngle: {
  Class, %ui_comp_expression;
  title, "Line Rotation Angle";
  units, "degrees",
  value, angular_offset:;
};
 
 
(Child) SelectLineRefPoint: {
  Class, %ui_comp_point;
  Point,reference_point:;
  SoUpdateOption, 3;
  NoHandle, False;
  LabelString, "Anchor Point";
  Scope, 1;
  GwifType, 0;
  Sensitivity, layout_strategy_name: = StraightLine;
};

(Child) SelectSpacingTable: {
  Class, %ui_comp_enum;
  title, "Select Spacing Table to use";
  value, if(empty?(readSpacingTablesDescriptions:)) then 0 else spacing_table_index: -1 ; # UI and KF count differently
  PresentationStyle, 0;
  TitleVisibility, true;
  BorderVisibility, true;
  RadioOrientation, 0;
  Titles, readSpacingTablesDescriptions: ;
};
		
	
(Child) Anchors: {
  Class, %ui_comp_enum;
  title, "Select anchor point:",
  value, 7; # bottom center is default, counted starting from 0 (UI and KF count differently)
  PresentationStyle, 0;
  TitleVisibility, true;
  BorderVisibility, true;
  RadioOrientation, 0;
  Titles, available_anchor_methods: ;
  Icons, {		# icon files (.bmp) need to be in %UGII_SITE_DIR%/startup
              "alignment_top-left", 		"alignment_top-center",  		"alignment_top-right",
              "alignment_mid-left", 		"alignment_mid-center",  		"alignment_mid-right",
              "alignment_bottom-left", 	"alignment_bottom-center",  "alignment_bottom-right"
            };
};

# distort, flip and other abuse
(Child) MogrifyGlyphsGroup: {
  Class, %ui_comp_group;
  title, "Transform Geometry";
  members, { 	UpsideDownToggle:, PointingAngleGroup:, SelectShearingAngle:};
  Column, 0;
  Group, true;
  Visibility,true;
};

(Child) PointingAngleGroup: {
  Class, %ui_comp_group;
  title, "Pointing Angle";
  members, { 	 SelectPointingAngle:, BowExpandToggle: };
  Column, 0;
  Group, true;
  Visibility, true;
};

(Child) UpsideDownToggle: {
  Class, %ui_comp_toggle;
	title, "upside down?",
  value, upside_down?:;
};

(Child) SelectPointingAngle: {
  Class, %ui_comp_double;
  value, pointing_angle:;
  unit, "";
  title, "Enter Pointing Angle";
  MaximumValue, 1.0e19;
  MinimumValue, -1.0e19;
  Width, 0;
  VisibleDecimals, 4;
};

(Child) BowExpandToggle: {
  Class, %ui_comp_toggle;
	title, "bow expand?",
  value, bow_expand?:,
	visibility, layout_strategy_name: = Circle;
};

(Child) SelectShearingAngle: {
  Class, %ui_comp_double;
  value, shearing_angle:;
  unit, "";
  title, "Enter Shearing Angle";
  MaximumValue, 1.0e19;
  MinimumValue, -1.0e19;
  Width, 0;
  VisibleDecimals, 4;
};


# multi text ui

(Child) multiTextUI:
{
	class, %swd_ui_multi_line;
  multi_line_text, text:;
	line_spacing_factor, line_spacing_factor:
};


# geometry
# Update Mechanism for UI blocks (Action Listeners)
# return value is discarded
(Method integer ) Update:(Instance $instance)
@{
		if ($instance = SelectFontList: ) 
		then
		@{      
      # open font file
      if ug_isUGManagerActive() 
      then 
          @{
              # to be filled in later, do nothing at the moment
              ug_printValue("Fill in TC code here");						
          }
      else
          @{
            storeFontSelection:();
            updateSpacingTableUi:();
						0;
          };     		
		} # end SelectFontList:
		else if ($instance = TextEntry: ) 
		then
		@{
  	 StoreValue(TextEntry:Value:, self:, text);
		 0;
		} # end TextEntry	
		else if ($instance = SelectFontSize: ) 
		then
		@{
  	 StoreValue(SelectFontSize:Value:, self:, font_size );
		 0;
		} # end SelectFontSize:
		else if ($instance = SelectSpacingFactor: ) 
		then
		@{
  	 StoreValue(SelectSpacingFactor:Value:, self:, spacing_factor );
		 0;
		} # end SelectSpacingFactor:
	  else if ($instance = SelectAngularOffset: ) 
		then
		@{
  	 	StoreValue(SelectAngularOffset:Value:, self:, angular_offset );
			0;
		} # end SelectAngularOffset
  	 else if ($instance = SelectCircleCenterPoint: ) 
		then
		@{
  	 StoreValue(SelectCircleCenterPoint:Point:, self:, reference_point );
		 0;
		} # end SelectAngularOffset
 	 else if ($instance = SelectLineRefPoint: ) 
		then
		@{			
      StoreValue(SelectLineRefPoint:Point:, self:, reference_point );
			0;
		} # end SelectAngularOffset
  	else if ($instance = SelectRotationAngle: ) 
		then
		@{
      StoreValue(SelectRotationAngle:Value:, self:, rotation_angle);		  
			0;
		} # end SelectFontSize:
			else if ($instance = SelectRadius: ) 
		then
		@{
  	 StoreValue(SelectRadius:Value:, self:,  circle_radius );
		 0;
		} # end SelectRadius
	  else if ($instance = SelectSpacingTable: ) 
		then
		@{
			storeSpacingTableIndex:();
			0;
		} 
    else if ($instance = SelectLayoutStrategy: ) 
		then
		@{
			storeLayoutStrategy:();
		  showLayoutOptions:(SelectLayoutStrategy:Value:);
			sizeConstraintMethodChanged:();			
			0;
		} # end SelectLayoutStrategy:
	 else if ($instance = UpsideDownToggle: ) 
		then
		@{			
			StoreValue(UpsideDownToggle:Value:, self:,  upside_down? );      
			0;
		}
	 else if ($instance = OpenMultiLineText: ) 
		then
		@{ 
  		callMultiLineTextDialogue:();
			0;
		}
		else if ($instance = BowExpandToggle: ) 
		then
		@{ 
			  StoreValue(BowExpandToggle:Value:, self:, bow_expand?);
			0;
		}
		else if ($instance = SelectPointingAngle: ) 
		then
		@{ 
			StoreValue(SelectPointingAngle:Value:, self:, pointing_angle);
			0;
		}
		else if ($instance = SelectShearingAngle: ) 
		then
		@{ 
			StoreValue(SelectShearingAngle:Value:, self:, shearing_angle);
			0;
		}
		else if ($instance = Anchors: ) 
		then
		@{ 
			storeAnchorValue:();
			0;
		}		
    else if ($instance = PositionEntry: ) 
		then
		@{ 
			StoreValue(PositionEntry:Value:, self:, meta_position);
			0;
		}
    else if ($instance = RemarkEntry: ) 
		then
		@{ 
			StoreValue(RemarkEntry:Value:, self:, meta_remark);
			0;
		}
    else if ($instance = DescriptionEntry: ) 
		then
		@{ 
			StoreValue(DescriptionEntry:Value:, self:, meta_description);
			0;
		}	
    else if ($instance = SelectSizeConstraintMethod: ) 
		then
		@{ 
			sizeConstraintMethodChanged:();
			0;
		}	
	  else if ($instance = SelectAngleRange:  ) 
		then
		@{ 
			StoreValue(SelectAngleRange:Value:, self:, angle_range);
			0;
		}	
		  else if ($instance = SelectExtent:  ) 
		then
		@{ 
			StoreValue(SelectExtent:Value:, self:, extent);
			0;
		}	
		else   @{	
      ActionUpdate:($instance);
      0;
  	};
		# on-the-fly geometry update while the UI is still opened
    if(UpdateButton:Value:) then
    {              
        tempUpdate:();  
    } else 0;      
	0;
};


(Any Method) storeAnchorValue:()
@{
	$ui_selected << Anchors:value:;
	$list_selected << $ui_selected + 1; # from 0 based in UI to 1 based in KF
	$selected << nth( $list_selected , available_anchor_methods:  );	
	StoreValue( $selected, self:, anchor_method );
};


(Any Method) storeLayoutStrategy:()
@{
	$ui_selected << SelectLayoutStrategy:Value:;
	$list_selected << $ui_selected + 1;	
	StoreValue( nth( $list_selected , layout_strategy_name_init: ), self:, layout_strategy_name );
};

# get a list of spacing table *names* from the currently selected font
# does _not_ push it forward into the UI
# does _not_ handle spacing tables, only their description
(List) readSpacingTablesDescriptions:
@{
	if(font_ref: != "") then @{	
    $open_return << ug_openPart( font_ref: );
		# TODO handle open failed		
    $descriptions << ug_askKFAttrValue(font_ref:, "swd_font:spacing_table_descriptions");    
    StoreValue($descriptions, self:,  spacing_table_descriptions );	
    $names << loop{
      for $descr in $descriptions;
      collect first($descr);
    };  
    $names;
	} else @{
		{}; # nothing to see here, move along
	};
};

# pushes table desciptions into the UI
(Any Method) updateSpacingTableUi:()
@{	
	$names << readSpacingTablesDescriptions:;
  %ui_comp_setCacheValue(self(), $names, SelectSpacingTable:, Titles );	
	0;
};

(Any Method) storeFontSelection:()
@{
	$selected << SelectFontList:Value: + 1; # add 1 to SelectFontList:value: since that counts from 0								
  $filename << first(nth($selected, installed_fonts:));				
  StoreValue($filename, self:  , font_ref );	
	StoreValue(nth($selected, installed_fonts_names:), self: , font_display_name );	
};

# NX 6 specific
(string) on_ok: on_apply: ;

# this is evaluated if you hit apply
# used for making sure all required data has been filled in
# returning a non-empty string -> something is missing
(string) on_apply: 
@{
	if ( font_ref: = "") then "Please select a font." else 
	if (text: = "") then "Please enter some text."  else
	@{
		# make sure there is a spacing table at the specified postion
		$index_too_large << SelectSpacingTable:Value: + 1 > length(spacing_table_descriptions:);
		$index_too_small << SelectSpacingTable:Value: + 1 <= 0;
    if ($index_too_large | $index_too_small) then
    @{
      "Please select a spacing table.";
      }
    else @{
			# ready, steady, off we go	
			$constraints << gatherConstraints:();
      $layout << swd_layout($constraints);
      StoreValue($layout, self:, layout);											
			
      StoreValue(true, self:, ok_to_create_geom);			
			ug_setObjectName(swd_geom_Text:, TextEntry:Value:);
					
      "";
    };
  }; 
};

# change UI depending on selected layoutStrategy
(Any Method) showLayoutOptions:(Integer $selection)
@{
		$circle_enabled << $selection = 0;
		
	  %ui_comp_setCacheValue(self(), $circle_enabled, PlaceOnCircleGroup:, Visibility );
		%ui_comp_setCacheValue(self(), $circle_enabled, SelectCircleCenterPoint:, Sensitivity );
		# bow expand only sensible if on circle -- there ain't no bow on a line
		%ui_comp_setCacheValue(self(), $circle_enabled, BowExpandToggle:, Visibility );		
		
		%ui_comp_setCacheValue(self(), !$circle_enabled, PlaceOnLineGroup:, Visibility );
		%ui_comp_setCacheValue(self(), !$circle_enabled, SelectLineRefPoint: , Sensitivity );
		
		if($circle_enabled) then 	%ui_comp_setCacheValue(self(), available_size_constraints_circle:, SelectSizeConstraintMethod:,  Titles ) else 
      %ui_comp_setCacheValue(self(), available_size_constraints_straight:, SelectSizeConstraintMethod:,  Titles );
		
};



# multi line text has its own dialog,
# because the regular ui_comp_string
# doesn't think that should be possible
(Any Method) callMultiLineTextDialogue:()
@{
  $ret_val << ug_invokeClassDialog( multiTextUI: );
  if($ret_Val == multiTextUI:ok_button: ) then @{
		# crutch for quirky new line values disappearing effect (ui and kf both seem to substitue/escape)
		$text << replaceString( multiTextUI:multi_line_text:, "~n", "~~n" );
    StoreValue($text, self:, text);
    StoreValue(multiTextUI:line_spacing_factor:, self:, line_spacing_factor);
    $display_string << subString(multiTextUI:multi_line_text:, 1, 3) + "...";
    %ui_comp_setCacheValue(self(), $display_string , TextEntry: , Value );           		
  } else {
    # do nothing
		0;
  };
};

(Method Integer) readStoredFontListIndex:()
@{
	$pos << Position(font_display_name:, installed_fonts_names: ) ;	# subtract KF list offset since it's going to the UI and that starts with 0
	$ret_val << if($pos = NoValue) then 0 else $pos -1;		
	$ret_val;
	};

(Method Integer) readStoredStrategyIndex:()
@{	
	$pos << Position(layout_strategy_name:, layout_strategy_name_init:);
	if($pos = NoValue) then 0 else $pos -1;
};

(Method Integer) readStoredSizeConstraintIndex:()
@{
	$pos << Position(size_constrained_by:, available_size_constraints:);
	if($pos = NoValue) then 0 else $pos -1;
};

(Method Any) storeSpacingTableIndex:()
@{
	$index << SelectSpacingTable:Value: + 1;
  StoreValue($index, self:, spacing_table_index);
};

(Method Any) sizeConstraintMethodChanged:()
@{

		$ui_selected << SelectSizeConstraintMethod:Value:;
		$list_selected << $ui_Selected +1;
		StoreValue(nth($list_selected, available_size_constraints:), self:, size_constrained_by );
		loop {
			for $control in size_constraint_controls:;
      do %ui_comp_setCacheValue(self(), false , $control, Visibility );           		
		};
	  %ui_comp_setCacheValue(self(), true , nth($list_selected,size_constraint_controls:), Visibility );         
};


# collects all parameters in a list of
# {key: string, value: any} lists
# and translate absolute coordinates 
# into the correct coordinate system
# (font defined in XY plane, all computations in XY, but used in ZY.
#  ref points are defined in ZY, but need to be in the same plane as the 
# font for computation)
(Method List) gatherConstraints:()
@{

  {
    {"start_point", reference_point:}, 
    {"arc_center",reference_point: },   
    {"angular_offset", angular_offset: },
    {"rotation_angle", rotation_angle: },
    {"spacing_factor", spacing_factor: },
    {"font_size", font_size: },
    {"circle_radius", circle_radius:},
    {"spacing_table_index", spacing_table_index:  },
    {"layout_strategy",  layout_strategy_name: },
    {"anchor_method",  anchor_method: },
    {"line_spacing_factor", line_spacing_factor: },
    {"font", font_ref:},
    {"text", text:},
    {"upside_down?", upside_down?: },
    {"bow_expand?", bow_expand?: },
    {"pointing_angle", pointing_angle: },
    {"shearing_angle", shearing_angle: },
    {"angle_range", angle_range: },					
    {"extent", extent: },
    {"size_constraint", size_constrained_by: },
  };
};

# used when update toggle is switched on
# will show results while UI is still open
(Method Any) tempUpdate:()
@{
	$constraints << gatherConstraints:();
  $layout << swd_layout($constraints);
  StoreValue($layout, self:, layout);										
	ug_setObjectName(swd_geom_Text:, TextEntry:Value:);
  ug_updateKFObjects({});
	0;
};

(Method integer) OnInitialize:(Instance $instance)
@{
   if($instance = SelectSpacingTable: ) then readSpacingTablesDescriptions: else 
	 0;
};


#+ 

#-

